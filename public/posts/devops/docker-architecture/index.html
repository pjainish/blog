<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Docker Architecture | Jainish&#39;s Log</title>
<meta name="keywords" content="">
<meta name="description" content="Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker&rsquo;s architecture.
Client-Server Architecture
At the heart of Docker&rsquo;s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as dockerd. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.">
<meta name="author" content="">
<link rel="canonical" href="https://pjainish.github.io/posts/devops/docker-architecture/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8fd9097ad76bddf704cd630b8ef895f18be00a4239538b567c948b65b650535f.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://pjainish.github.io/assets/images/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://pjainish.github.io/assets/images/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://pjainish.github.io/assets/images/favicon.png">
<link rel="apple-touch-icon" href="https://pjainish.github.io/assets/images/favicon.png">
<link rel="mask-icon" href="https://pjainish.github.io/assets/images/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://pjainish.github.io/posts/devops/docker-architecture/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js" integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa" crossorigin="anonymous"
    onload="renderMathInElement(document.body);"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>



<script async src="https://www.googletagmanager.com/gtag/js?id=G-79V8YMLKHG"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-79V8YMLKHG');
</script>


<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7034991413277510"
     crossorigin="anonymous"></script><meta property="og:url" content="https://pjainish.github.io/posts/devops/docker-architecture/">
  <meta property="og:site_name" content="Jainish&#39;s Log">
  <meta property="og:title" content="Docker Architecture">
  <meta property="og:description" content="Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker’s architecture.
Client-Server Architecture At the heart of Docker’s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as dockerd. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.">
  <meta property="og:locale" content="en-us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-12-21T19:45:51+05:30">
    <meta property="article:modified_time" content="2024-12-21T19:45:51+05:30">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Docker Architecture">
<meta name="twitter:description" content="Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker&rsquo;s architecture.
Client-Server Architecture
At the heart of Docker&rsquo;s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as dockerd. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://pjainish.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Docker Architecture",
      "item": "https://pjainish.github.io/posts/devops/docker-architecture/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker Architecture",
  "name": "Docker Architecture",
  "description": "Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker\u0026rsquo;s architecture.\nClient-Server Architecture At the heart of Docker\u0026rsquo;s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as dockerd. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.\n",
  "keywords": [
    
  ],
  "articleBody": "Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker’s architecture.\nClient-Server Architecture At the heart of Docker’s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as dockerd. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.\nThe Docker client can connect to multiple daemons, enabling users to manage containers across different hosts. This remote connectivity is particularly useful in scenarios where containers need to be managed from a central location or when working with distributed systems.\nDocker Client The Docker client is the interface through which users interact with the Docker daemon. It enables users to issue commands such as docker build, docker pull, and docker run using a Command-Line Interface (CLI). The Docker client can deliver these commands to the Docker daemon, which then executes them.\nThe Docker client offers fine-grained control over Docker operations, making it suitable for advanced users. It allows users to manage Docker containers, images, networks, volumes, and other Docker objects efficiently. Users can perform actions such as creating, starting, stopping, and deleting containers, as well as pulling, pushing, tagging, building, or inspecting images. These actions can be performed using the command line or through visual desktop applications.\nIn addition to the CLI, tools like Docker Compose extend the capabilities of the Docker client. Docker Compose allows users to work with applications consisting of multiple containers by defining the application’s services in a docker-compose.yml file. This simplifies the management of complex applications and ensures that all necessary containers are started and configured correctly.\nDocker Daemon (Docker Engine) The Docker daemon, or dockerd, is the core element of the Docker architecture. It listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. The daemon communicates via a REST API over UNIX sockets or a network interface, allowing it to receive commands from the Docker client and execute them accordingly.\nThe Docker daemon is responsible for building, running, and distributing Docker containers. It controls the container services and communicates with other daemons to manage Docker services. This communication is essential for orchestrating containers across multiple hosts, especially in swarm mode.\nDocker Host The Docker Host provides the environment where Docker containers are created, tested, and run. It includes the Docker daemon, containers, images, networks, and storage. The Docker Host can be a local machine, a virtual machine, or a cloud instance. It is the foundational layer that supports the entire Docker ecosystem, ensuring that all necessary components are available for container execution.\nThe Docker Host is where the Docker daemon runs, managing all Docker objects and services. It provides the necessary resources such as CPU, memory, and storage for the containers to operate.\nDocker Images Docker images are read-only templates used to build Docker containers. They consist of a set of instructions and files necessary to create a container from scratch. Images follow a layered architecture, using a copy-on-write (CoW) mechanism to optimize storage and performance. Each layer in the image represents a change or addition to the previous layer, allowing for efficient use of storage.\nWhen a container is created from an image, a writable layer is added on top of the read-only layers of the image. This writable layer allows the container to make changes without altering the underlying image. Understanding Docker images is crucial for building and managing containers effectively.\nDocker Containers Docker containers are runtime instances of Docker images. They are isolated from each other and the host system using namespaces and control groups (cgroups). Namespaces provide isolation of system resources such as processes, network, and users, while cgroups limit and isolate resource usage (CPU, memory, disk I/O) of containers.\nThe lifecycle of a container includes creation, running, stopping, and deleting. Containers can be managed using various commands such as docker run, docker stop, and docker rm. The isolation and resource management features of containers make them lightweight and efficient compared to traditional virtual machines.\nContainers are defined by their image as well as any configuration options provided when they are created or started. When a container is removed, any changes to its state that aren’t stored in persistent storage disappear.\nDocker Registry The Docker Registry is a central repository for storing and sharing Docker images. Docker Hub is the most well-known public registry, but users can also set up private registries for internal use. The registry allows users to push and pull images, making it easier to distribute and manage images across different environments.\nPublic registries like Docker Hub provide access to a vast array of community-built images, while private registries offer a secure way to store and manage proprietary images. Understanding how to use registries is essential for managing and deploying Docker images efficiently.\nDocker Networking Docker provides several networking modes to facilitate communication between containers and the host system:\nBridge: The default mode, where containers connect to a private internal network on the host. Host: Removes network isolation between the container and the Docker host, allowing the container to use the host’s network stack. None: Disables all networking for the container. Overlay: Enables swarm services to communicate with each other across nodes. Macvlan: Assigns a MAC address to each container, making them appear as physical devices on the network. Custom Networks: User-defined networks for more complex scenarios. These networking modes provide flexibility in how containers communicate, making it easier to configure and manage container networks according to specific needs.\nDocker Volumes Docker volumes are used for persistent data storage. Unlike the ephemeral nature of containers, volumes persist even after a container is deleted. There are several types of volumes:\nData Volumes: Directories within the container’s filesystem that are backed by host directories. Volume Containers: Special containers that provide volumes to other containers. Directory Mounts: Host directories mounted into the container’s filesystem. Storage Plugins: Third-party plugins that provide additional storage options. Volumes are essential for sharing data between containers and the host system, ensuring that data is preserved across container restarts and deletions.\nDocker Compose Docker Compose is a tool for defining and running multi-container Docker applications. It simplifies the process of managing complex applications by allowing users to define the application’s services in a docker-compose.yml file. Common commands like docker-compose up, docker-compose down, and docker-compose build make it easy to start, stop, and build the entire application.\nDocker Compose is particularly useful in development environments where multiple services need to be coordinated. It ensures that all necessary containers are started and configured correctly, streamlining the development and testing process.\nDocker Swarm Docker Swarm is Docker’s built-in container orchestration tool. It integrates seamlessly with the Docker platform, providing features such as ease of use, native Docker API integration, load balancing, service discovery, rolling updates, and declarative scaling.\nDocker Swarm is designed to manage a cluster of Docker hosts as a single unit, making it easier to deploy and manage containerized applications at scale. While it is not as feature-rich as Kubernetes, Docker Swarm offers a simpler and more intuitive way to orchestrate containers, especially for smaller to medium-sized deployments.\nSecurity and Isolation Docker’s architecture includes several security and isolation features:\nNamespaces: Provide isolation of system resources such as processes, network, and users. Control Groups (cgroups): Limit and isolate resource usage (CPU, memory, disk I/O) of containers. Content Trust: Ensures the integrity and authenticity of Docker images through trust delegation and notary services. These features ensure that containers are isolated from each other and the host system, enhancing the overall security and reliability of the Docker environment.\nStorage Management Storage management in Docker involves several components:\nStorage Drivers: Manage the storage of images and containers on the Docker host. Data Volumes: Provide persistent storage for containers. Volume Containers: Special containers that provide volumes to other containers. Directory Mounts: Host directories mounted into the container’s filesystem. Storage Plugins: Third-party plugins that provide additional storage options. Understanding these components is crucial for managing and optimizing storage in Docker environments.\nContinuous Integration and Continuous Deployment (CI/CD) Docker integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines. Docker images can be built, managed, and distributed as part of a CI/CD workflow, ensuring that applications are consistently and reliably deployed.\nTools like AWS CodeBuild and Docker Build Cloud can be integrated into CI/CD pipelines to automate the build process, reducing build times and improving release frequency. This integration is essential for modern software development practices, enabling teams to build, test, and deploy applications more efficiently.\nDockerfile Instructions Dockerfiles are scripts used to build Docker images. They contain instructions such as FROM, RUN, COPY, and CMD that define how the image is built. Optimizing Dockerfiles is crucial for better performance and security. Best practices include minimizing the number of layers, using multi-stage builds, and avoiding unnecessary commands.\nUnderstanding Dockerfile instructions is essential for creating efficient and secure Docker images. Advanced instructions and best practices can significantly improve the build process and the resulting image.\nAdvanced Docker Components Several advanced components enhance the functionality and security of Docker:\nDocker Content Trust: Ensures the integrity and authenticity of Docker images. Notary: A tool for managing trust keys and delegations. Transport Layer Security (TLS): Configuring TLS for secure communication between the Docker client and daemon. These components are vital for ensuring the security and reliability of Docker environments, especially in production settings.\nBest Practices and Use Cases Using Docker effectively involves following best practices for different scenarios:\nDevelopment: Use Docker Compose to manage multi-container applications. Testing: Utilize Docker’s isolation features to test applications in a controlled environment. Production: Implement Docker Swarm or other orchestration tools for scaling and managing containerized applications. Real-world use cases illustrate the benefits and applications of Docker. For example, Docker can be used to modernize legacy applications, simplify development workflows, and improve deployment efficiency.\nTroubleshooting and Debugging Troubleshooting and debugging Docker containers and images involve several tools and techniques:\nDocker Logs: Use docker logs to view container logs. Container Inspection: Use docker inspect to view detailed information about containers. Diagnostic Tools: Use tools like docker stats and docker top to monitor container performance. Common issues such as network connectivity problems, resource constraints, and image build errors can be resolved using these diagnostic tools. Understanding how to troubleshoot and debug Docker environments is crucial for maintaining reliable and efficient containerized applications.\nConclusion Docker’s architecture is designed to provide a robust, flexible, and scalable platform for containerization. By understanding the client-server model, Docker client, Docker daemon, Docker Host, images, containers, registries, networking, volumes, and other advanced components, users can leverage Docker to streamline their development, testing, and deployment processes. Whether you are a developer, tester, or operations engineer, mastering Docker’s architecture is key to unlocking its full potential.\n",
  "wordCount" : "1835",
  "inLanguage": "en",
  "datePublished": "2024-12-21T19:45:51+05:30",
  "dateModified": "2024-12-21T19:45:51+05:30",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://pjainish.github.io/posts/devops/docker-architecture/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Jainish's Log",
    "logo": {
      "@type": "ImageObject",
      "url": "https://pjainish.github.io/assets/images/favicon.png"
    }
  }
}
</script>
</head>

<body class=" dark" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://pjainish.github.io/" accesskey="h" title="Jainish&#39;s Log (Alt + H)">
                <img src="https://pjainish.github.io/assets/images/favicon.png" alt="" aria-label="logo"
                    height="30">Jainish&#39;s Log</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://pjainish.github.io/" title="Posts">
                    <span>Posts</span>
                </a>
            </li>
            <li>
                <a href="https://pjainish.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://pjainish.github.io/posts/top-100/" title="Top 100">
                    <span>Top 100</span>
                </a>
            </li>
            <li>
                <a href="https://pjainish.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://pjainish.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://pjainish.github.io/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://pjainish.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://pjainish.github.io/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Docker Architecture
    </h1>
    <div class="post-meta"><span title='2024-12-21 19:45:51 +0530 IST'>December 21, 2024</span>&nbsp;·&nbsp;9 min

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul><ul>
                <li>
                    <a href="#client-server-architecture" aria-label="Client-Server Architecture">Client-Server Architecture</a></li>
                <li>
                    <a href="#docker-client" aria-label="Docker Client">Docker Client</a></li>
                <li>
                    <a href="#docker-daemon-docker-engine" aria-label="Docker Daemon (Docker Engine)">Docker Daemon (Docker Engine)</a></li>
                <li>
                    <a href="#docker-host" aria-label="Docker Host">Docker Host</a></li>
                <li>
                    <a href="#docker-images" aria-label="Docker Images">Docker Images</a></li>
                <li>
                    <a href="#docker-containers" aria-label="Docker Containers">Docker Containers</a></li>
                <li>
                    <a href="#docker-registry" aria-label="Docker Registry">Docker Registry</a></li>
                <li>
                    <a href="#docker-networking" aria-label="Docker Networking">Docker Networking</a></li>
                <li>
                    <a href="#docker-volumes" aria-label="Docker Volumes">Docker Volumes</a></li>
                <li>
                    <a href="#docker-compose" aria-label="Docker Compose">Docker Compose</a></li>
                <li>
                    <a href="#docker-swarm" aria-label="Docker Swarm">Docker Swarm</a></li>
                <li>
                    <a href="#security-and-isolation" aria-label="Security and Isolation">Security and Isolation</a></li>
                <li>
                    <a href="#storage-management" aria-label="Storage Management">Storage Management</a></li>
                <li>
                    <a href="#continuous-integration-and-continuous-deployment-cicd" aria-label="Continuous Integration and Continuous Deployment (CI/CD)">Continuous Integration and Continuous Deployment (CI/CD)</a></li>
                <li>
                    <a href="#dockerfile-instructions" aria-label="Dockerfile Instructions">Dockerfile Instructions</a></li>
                <li>
                    <a href="#advanced-docker-components" aria-label="Advanced Docker Components">Advanced Docker Components</a></li>
                <li>
                    <a href="#best-practices-and-use-cases" aria-label="Best Practices and Use Cases">Best Practices and Use Cases</a></li>
                <li>
                    <a href="#troubleshooting-and-debugging" aria-label="Troubleshooting and Debugging">Troubleshooting and Debugging</a></li></ul>
                    
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Docker, a leading containerization platform, simplifies the process of developing, shipping, and running applications by providing a robust and flexible architecture. Here is a detailed overview of the various components and features of Docker&rsquo;s architecture.</p>
<h3 id="client-server-architecture">Client-Server Architecture<a hidden class="anchor" aria-hidden="true" href="#client-server-architecture">#</a></h3>
<p>At the heart of Docker&rsquo;s architecture is a client-server model. In this setup, the Docker client interacts with the Docker daemon, also known as <code>dockerd</code>. This client-server architecture allows for flexibility in how the client and daemon are deployed. They can either run on the same host or communicate remotely over a network interface or UNIX sockets. This flexibility is crucial for both local development and distributed environments.</p>
<p>The Docker client can connect to multiple daemons, enabling users to manage containers across different hosts. This remote connectivity is particularly useful in scenarios where containers need to be managed from a central location or when working with distributed systems.</p>
<h3 id="docker-client">Docker Client<a hidden class="anchor" aria-hidden="true" href="#docker-client">#</a></h3>
<p>The Docker client is the interface through which users interact with the Docker daemon. It enables users to issue commands such as <code>docker build</code>, <code>docker pull</code>, and <code>docker run</code> using a Command-Line Interface (CLI). The Docker client can deliver these commands to the Docker daemon, which then executes them.</p>
<p>The Docker client offers fine-grained control over Docker operations, making it suitable for advanced users. It allows users to manage Docker containers, images, networks, volumes, and other Docker objects efficiently. Users can perform actions such as creating, starting, stopping, and deleting containers, as well as pulling, pushing, tagging, building, or inspecting images. These actions can be performed using the command line or through visual desktop applications.</p>
<p>In addition to the CLI, tools like Docker Compose extend the capabilities of the Docker client. Docker Compose allows users to work with applications consisting of multiple containers by defining the application&rsquo;s services in a <code>docker-compose.yml</code> file. This simplifies the management of complex applications and ensures that all necessary containers are started and configured correctly.</p>
<h3 id="docker-daemon-docker-engine">Docker Daemon (Docker Engine)<a hidden class="anchor" aria-hidden="true" href="#docker-daemon-docker-engine">#</a></h3>
<p>The Docker daemon, or <code>dockerd</code>, is the core element of the Docker architecture. It listens for Docker API requests and manages Docker objects such as images, containers, networks, and volumes. The daemon communicates via a REST API over UNIX sockets or a network interface, allowing it to receive commands from the Docker client and execute them accordingly.</p>
<p>The Docker daemon is responsible for building, running, and distributing Docker containers. It controls the container services and communicates with other daemons to manage Docker services. This communication is essential for orchestrating containers across multiple hosts, especially in swarm mode.</p>
<h3 id="docker-host">Docker Host<a hidden class="anchor" aria-hidden="true" href="#docker-host">#</a></h3>
<p>The Docker Host provides the environment where Docker containers are created, tested, and run. It includes the Docker daemon, containers, images, networks, and storage. The Docker Host can be a local machine, a virtual machine, or a cloud instance. It is the foundational layer that supports the entire Docker ecosystem, ensuring that all necessary components are available for container execution.</p>
<p>The Docker Host is where the Docker daemon runs, managing all Docker objects and services. It provides the necessary resources such as CPU, memory, and storage for the containers to operate.</p>
<h3 id="docker-images">Docker Images<a hidden class="anchor" aria-hidden="true" href="#docker-images">#</a></h3>
<p>Docker images are read-only templates used to build Docker containers. They consist of a set of instructions and files necessary to create a container from scratch. Images follow a layered architecture, using a copy-on-write (CoW) mechanism to optimize storage and performance. Each layer in the image represents a change or addition to the previous layer, allowing for efficient use of storage.</p>
<p>When a container is created from an image, a writable layer is added on top of the read-only layers of the image. This writable layer allows the container to make changes without altering the underlying image. Understanding Docker images is crucial for building and managing containers effectively.</p>
<h3 id="docker-containers">Docker Containers<a hidden class="anchor" aria-hidden="true" href="#docker-containers">#</a></h3>
<p>Docker containers are runtime instances of Docker images. They are isolated from each other and the host system using namespaces and control groups (cgroups). Namespaces provide isolation of system resources such as processes, network, and users, while cgroups limit and isolate resource usage (CPU, memory, disk I/O) of containers.</p>
<p>The lifecycle of a container includes creation, running, stopping, and deleting. Containers can be managed using various commands such as <code>docker run</code>, <code>docker stop</code>, and <code>docker rm</code>. The isolation and resource management features of containers make them lightweight and efficient compared to traditional virtual machines.</p>
<p>Containers are defined by their image as well as any configuration options provided when they are created or started. When a container is removed, any changes to its state that aren&rsquo;t stored in persistent storage disappear.</p>
<h3 id="docker-registry">Docker Registry<a hidden class="anchor" aria-hidden="true" href="#docker-registry">#</a></h3>
<p>The Docker Registry is a central repository for storing and sharing Docker images. Docker Hub is the most well-known public registry, but users can also set up private registries for internal use. The registry allows users to push and pull images, making it easier to distribute and manage images across different environments.</p>
<p>Public registries like Docker Hub provide access to a vast array of community-built images, while private registries offer a secure way to store and manage proprietary images. Understanding how to use registries is essential for managing and deploying Docker images efficiently.</p>
<h3 id="docker-networking">Docker Networking<a hidden class="anchor" aria-hidden="true" href="#docker-networking">#</a></h3>
<p>Docker provides several networking modes to facilitate communication between containers and the host system:</p>
<ul>
<li><strong>Bridge</strong>: The default mode, where containers connect to a private internal network on the host.</li>
<li><strong>Host</strong>: Removes network isolation between the container and the Docker host, allowing the container to use the host&rsquo;s network stack.</li>
<li><strong>None</strong>: Disables all networking for the container.</li>
<li><strong>Overlay</strong>: Enables swarm services to communicate with each other across nodes.</li>
<li><strong>Macvlan</strong>: Assigns a MAC address to each container, making them appear as physical devices on the network.</li>
<li><strong>Custom Networks</strong>: User-defined networks for more complex scenarios.</li>
</ul>
<p>These networking modes provide flexibility in how containers communicate, making it easier to configure and manage container networks according to specific needs.</p>
<h3 id="docker-volumes">Docker Volumes<a hidden class="anchor" aria-hidden="true" href="#docker-volumes">#</a></h3>
<p>Docker volumes are used for persistent data storage. Unlike the ephemeral nature of containers, volumes persist even after a container is deleted. There are several types of volumes:</p>
<ul>
<li><strong>Data Volumes</strong>: Directories within the container&rsquo;s filesystem that are backed by host directories.</li>
<li><strong>Volume Containers</strong>: Special containers that provide volumes to other containers.</li>
<li><strong>Directory Mounts</strong>: Host directories mounted into the container&rsquo;s filesystem.</li>
<li><strong>Storage Plugins</strong>: Third-party plugins that provide additional storage options.</li>
</ul>
<p>Volumes are essential for sharing data between containers and the host system, ensuring that data is preserved across container restarts and deletions.</p>
<h3 id="docker-compose">Docker Compose<a hidden class="anchor" aria-hidden="true" href="#docker-compose">#</a></h3>
<p>Docker Compose is a tool for defining and running multi-container Docker applications. It simplifies the process of managing complex applications by allowing users to define the application&rsquo;s services in a <code>docker-compose.yml</code> file. Common commands like <code>docker-compose up</code>, <code>docker-compose down</code>, and <code>docker-compose build</code> make it easy to start, stop, and build the entire application.</p>
<p>Docker Compose is particularly useful in development environments where multiple services need to be coordinated. It ensures that all necessary containers are started and configured correctly, streamlining the development and testing process.</p>
<h3 id="docker-swarm">Docker Swarm<a hidden class="anchor" aria-hidden="true" href="#docker-swarm">#</a></h3>
<p>Docker Swarm is Docker&rsquo;s built-in container orchestration tool. It integrates seamlessly with the Docker platform, providing features such as ease of use, native Docker API integration, load balancing, service discovery, rolling updates, and declarative scaling.</p>
<p>Docker Swarm is designed to manage a cluster of Docker hosts as a single unit, making it easier to deploy and manage containerized applications at scale. While it is not as feature-rich as Kubernetes, Docker Swarm offers a simpler and more intuitive way to orchestrate containers, especially for smaller to medium-sized deployments.</p>
<h3 id="security-and-isolation">Security and Isolation<a hidden class="anchor" aria-hidden="true" href="#security-and-isolation">#</a></h3>
<p>Docker&rsquo;s architecture includes several security and isolation features:</p>
<ul>
<li><strong>Namespaces</strong>: Provide isolation of system resources such as processes, network, and users.</li>
<li><strong>Control Groups (cgroups)</strong>: Limit and isolate resource usage (CPU, memory, disk I/O) of containers.</li>
<li><strong>Content Trust</strong>: Ensures the integrity and authenticity of Docker images through trust delegation and notary services.</li>
</ul>
<p>These features ensure that containers are isolated from each other and the host system, enhancing the overall security and reliability of the Docker environment.</p>
<h3 id="storage-management">Storage Management<a hidden class="anchor" aria-hidden="true" href="#storage-management">#</a></h3>
<p>Storage management in Docker involves several components:</p>
<ul>
<li><strong>Storage Drivers</strong>: Manage the storage of images and containers on the Docker host.</li>
<li><strong>Data Volumes</strong>: Provide persistent storage for containers.</li>
<li><strong>Volume Containers</strong>: Special containers that provide volumes to other containers.</li>
<li><strong>Directory Mounts</strong>: Host directories mounted into the container&rsquo;s filesystem.</li>
<li><strong>Storage Plugins</strong>: Third-party plugins that provide additional storage options.</li>
</ul>
<p>Understanding these components is crucial for managing and optimizing storage in Docker environments.</p>
<h3 id="continuous-integration-and-continuous-deployment-cicd">Continuous Integration and Continuous Deployment (CI/CD)<a hidden class="anchor" aria-hidden="true" href="#continuous-integration-and-continuous-deployment-cicd">#</a></h3>
<p>Docker integrates seamlessly with continuous integration and continuous deployment (CI/CD) pipelines. Docker images can be built, managed, and distributed as part of a CI/CD workflow, ensuring that applications are consistently and reliably deployed.</p>
<p>Tools like AWS CodeBuild and Docker Build Cloud can be integrated into CI/CD pipelines to automate the build process, reducing build times and improving release frequency. This integration is essential for modern software development practices, enabling teams to build, test, and deploy applications more efficiently.</p>
<h3 id="dockerfile-instructions">Dockerfile Instructions<a hidden class="anchor" aria-hidden="true" href="#dockerfile-instructions">#</a></h3>
<p>Dockerfiles are scripts used to build Docker images. They contain instructions such as <code>FROM</code>, <code>RUN</code>, <code>COPY</code>, and <code>CMD</code> that define how the image is built. Optimizing Dockerfiles is crucial for better performance and security. Best practices include minimizing the number of layers, using multi-stage builds, and avoiding unnecessary commands.</p>
<p>Understanding Dockerfile instructions is essential for creating efficient and secure Docker images. Advanced instructions and best practices can significantly improve the build process and the resulting image.</p>
<h3 id="advanced-docker-components">Advanced Docker Components<a hidden class="anchor" aria-hidden="true" href="#advanced-docker-components">#</a></h3>
<p>Several advanced components enhance the functionality and security of Docker:</p>
<ul>
<li><strong>Docker Content Trust</strong>: Ensures the integrity and authenticity of Docker images.</li>
<li><strong>Notary</strong>: A tool for managing trust keys and delegations.</li>
<li><strong>Transport Layer Security (TLS)</strong>: Configuring TLS for secure communication between the Docker client and daemon.</li>
</ul>
<p>These components are vital for ensuring the security and reliability of Docker environments, especially in production settings.</p>
<h3 id="best-practices-and-use-cases">Best Practices and Use Cases<a hidden class="anchor" aria-hidden="true" href="#best-practices-and-use-cases">#</a></h3>
<p>Using Docker effectively involves following best practices for different scenarios:</p>
<ul>
<li><strong>Development</strong>: Use Docker Compose to manage multi-container applications.</li>
<li><strong>Testing</strong>: Utilize Docker&rsquo;s isolation features to test applications in a controlled environment.</li>
<li><strong>Production</strong>: Implement Docker Swarm or other orchestration tools for scaling and managing containerized applications.</li>
</ul>
<p>Real-world use cases illustrate the benefits and applications of Docker. For example, Docker can be used to modernize legacy applications, simplify development workflows, and improve deployment efficiency.</p>
<h3 id="troubleshooting-and-debugging">Troubleshooting and Debugging<a hidden class="anchor" aria-hidden="true" href="#troubleshooting-and-debugging">#</a></h3>
<p>Troubleshooting and debugging Docker containers and images involve several tools and techniques:</p>
<ul>
<li><strong>Docker Logs</strong>: Use <code>docker logs</code> to view container logs.</li>
<li><strong>Container Inspection</strong>: Use <code>docker inspect</code> to view detailed information about containers.</li>
<li><strong>Diagnostic Tools</strong>: Use tools like <code>docker stats</code> and <code>docker top</code> to monitor container performance.</li>
</ul>
<p>Common issues such as network connectivity problems, resource constraints, and image build errors can be resolved using these diagnostic tools. Understanding how to troubleshoot and debug Docker environments is crucial for maintaining reliable and efficient containerized applications.</p>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>Docker&rsquo;s architecture is designed to provide a robust, flexible, and scalable platform for containerization. By understanding the client-server model, Docker client, Docker daemon, Docker Host, images, containers, registries, networking, volumes, and other advanced components, users can leverage Docker to streamline their development, testing, and deployment processes. Whether you are a developer, tester, or operations engineer, mastering Docker&rsquo;s architecture is key to unlocking its full potential.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>

<ul class="share-buttons">
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on x"
            href="https://x.com/intent/tweet/?text=Docker%20Architecture&amp;url=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f&amp;hashtags=">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M512 62.554 L 512 449.446 C 512 483.97 483.97 512 449.446 512 L 62.554 512 C 28.03 512 0 483.97 0 449.446 L 0 62.554 C 0 28.03 28.029 0 62.554 0 L 449.446 0 C 483.971 0 512 28.03 512 62.554 Z M 269.951 190.75 L 182.567 75.216 L 56 75.216 L 207.216 272.95 L 63.9 436.783 L 125.266 436.783 L 235.9 310.383 L 332.567 436.783 L 456 436.783 L 298.367 228.367 L 432.367 75.216 L 371.033 75.216 Z M 127.633 110 L 164.101 110 L 383.481 400.065 L 349.5 400.065 Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on linkedin"
            href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f&amp;title=Docker%20Architecture&amp;summary=Docker%20Architecture&amp;source=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on reddit"
            href="https://reddit.com/submit?url=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f&title=Docker%20Architecture">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on facebook"
            href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on whatsapp"
            href="https://api.whatsapp.com/send?text=Docker%20Architecture%20-%20https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f">
            <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve" height="30px" width="30px" fill="currentColor">
                <path
                    d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on telegram"
            href="https://telegram.me/share/url?text=Docker%20Architecture&amp;url=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f">
            <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28" height="30px" width="30px" fill="currentColor">
                <path
                    d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
            </svg>
        </a>
    </li>
    <li>
        <a target="_blank" rel="noopener noreferrer" aria-label="share Docker Architecture on ycombinator"
            href="https://news.ycombinator.com/submitlink?t=Docker%20Architecture&u=https%3a%2f%2fpjainish.github.io%2fposts%2fdevops%2fdocker-architecture%2f">
            <svg version="1.1" xml:space="preserve" width="30px" height="30px" viewBox="0 0 512 512" fill="currentColor"
                xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape">
                <path
                    d="M449.446 0C483.971 0 512 28.03 512 62.554L512 449.446C512 483.97 483.97 512 449.446 512L62.554 512C28.03 512 0 483.97 0 449.446L0 62.554C0 28.03 28.029 0 62.554 0L449.446 0ZM183.8767 87.9921H121.8427L230.6673 292.4508V424.0079H281.3328V292.4508L390.1575 87.9921H328.1233L256 238.2489z" />
            </svg>
        </a>
    </li>
</ul>

  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://pjainish.github.io/">Jainish&#39;s Log</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
